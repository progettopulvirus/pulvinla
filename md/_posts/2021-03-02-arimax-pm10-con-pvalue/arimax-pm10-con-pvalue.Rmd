---
title: "ARIMAX serie PM10, gennaio-maggio 2020 "
description: |
  Stima modello arimax utilizzando il valore dell'inquinante del giorno precedente.
author:
  - name: guidofioravanti
date: 03-02-2021
params:
  inquinante: pm10
output:
  distill::distill_article:
    self_contained: false
---

Per ciascuna serie di `r params$inquinante`  e' stato stimato (in modo completamente automatico) un modello ARIMAX utilizzando la funzione auto.arima del pacchetto `forecast`, imponendo come massimo ordine della componente AR p=1 e 0 come massimo ordine della componente MA (il modello INLA prevede una componente AR1 su spde e nessuna componente MA).

La variabile target (value) e' il logaritmo del dato osservato.

Le variabili prese in esame sono:

- le variabili meteoclimatiche

- la variabile **banda** (variabile che assume valori da 1 al numero dei giorni)

- la variabile **wday** (variabile che assume valori da 1 a 7, per cogliere un eventuale ciclo settimanale)

- la variabile **pvalue** (previous value, ovvero il valore dell'inquinante, in scala logaritmica, nel giorno precedente.)

- la variabile **lockdown** (variabile che assume valore 0 dal 1 gennaio 2020 al 7 marzo, per poi assumere valore 1 fino a fine serie)

```{r,include=TRUE,echo=FALSE,message=FALSE,warning=FALSE}
library("tidyverse")
library("forecast")
library("sf")
library("sp")
#devtools::install_github("progettopulvirus/rpulvinla")
library("rpulvinla")
options(warn=0)

set.seed(1)


#############################
###Regione e inquinante: fissare REGIONE e INQUINANTE
#############################
REGIONE<-"lombardia" #viene usato come suffisso per file output e per disegnare la regione nella mesh (solo disegnare, non per costruire la mesh)
INQUINANTE<-params$inquinante #inquinante su cui lavorare 

caricaDati(pacchetto=REGIONE,inquinante=INQUINANTE)->datiTemp

datiTemp %>% 
  filter(mm %in% seq(1,5) & yy==2020)->datiTemp #gennaio..maggio 2020 

###############################
###Trasformazione logaritmica della variabile target?
###############################
LOGARITMO<-c(TRUE,FALSE)[1] 

#####
# Inserire trend temporale (esterno a spde)?
#####
DAY_TREND<-c(TRUE,FALSE)[1] #rw1 su giorno? ..usare variabile day

WEEK_TREND<-c(TRUE,FALSE)[2] #rw1 su settimana? ... variabile week

WDAY_TREND<-c(TRUE,FALSE)[1] #rw1 su giorno della settimana, lun, mar..dom? ... variabile wday  

#dati meteo standardizzati
datiMeteo::meteo_standardizzati->meteo

#dati ok? verifichiamo
which(is.na(datiTemp$pollutant_fk))->righe
if(length(righe)) stop("pollutant_fk NA???")

#rpulvinla::prepara_dati, aggiunge la variabile banda per l'SPDE, fa il logaritmo della variabile value (l'inquinante) e aggiunge la variabile lockdown
prepara_dati(.x = datiTemp,previous=TRUE,logaritmo = LOGARITMO,lockdown = TRUE,wday=WDAY_TREND,day=DAY_TREND,week=WEEK_TREND)->dati

dati %>%
  mutate(seno=sin(2*pi*banda/7),coseno=cos(2*pi*banda/7))->dati
#update(myformula,.~.+seno+coseno)->myformula

#Sia che lavoriamo con il logaritmo dell'inquinante, sia che lavoriamo con la variabile originale, nella creazione dello stack chiamiamo la variabile
#target "value", in modo di avere un'unica interfaccia e toccare il meno possibile il codice

if(LOGARITMO){
  
  dati$value<-dati$lvalue
  dati$lvalue<-NULL
  
  dati$pvalue<-dati$lpvalue
  
  
}#fine LOGARITMO  
```

```{r,include=FALSE,echo=FALSE,message=FALSE,warning=FALSE}
#associo dati meteo
left_join(dati,meteo)->dati
rm(datiTemp)


left_join(dati,stazioniMonitoraggio::stazioni,by=c("station_eu_code"="station_eu_code"))->dati
```

### Stazioni Urban

```{r,include=TRUE,echo=TRUE,message=FALSE,warning=FALSE}
purrr::walk(c("U"),.f=function(tipo){
  
    dati[dati$tipo_zona==tipo,]->dati2  
    
    #Altre info
    unique(dati2$station_eu_code)->CODICI
    
    purrr::walk(CODICI,.f=function(cc){
      dati2[dati2$station_eu_code==cc,]->subdati
      imputeTS::na_ma(subdati$value)->subdati$value
    
      auto.arima(y=subdati$value,xreg = as.matrix(subdati[,c("banda","t2m","sp","pblmax","pblmin","wdir","wspeed","tp","ptp","pvalue","lockdown")]),
                 stepwise = TRUE,max.p=1,max.q=0)->ris
      
      print("###########################################\n")
      print(paste0("Codice stazione (station_eu_code):",cc))
      print("###########################################\n")      
      summary(ris)
      
    })


})
```


### Stazioni Suburban

```{r,include=TRUE,echo=TRUE,message=FALSE,warning=FALSE}
purrr::walk(c("S"),.f=function(tipo){
  
    dati[dati$tipo_zona==tipo,]->dati2  
    
    #Altre info
    unique(dati2$station_eu_code)->CODICI
    
    purrr::walk(CODICI,.f=function(cc){
      dati2[dati2$station_eu_code==cc,]->subdati
      imputeTS::na_ma(subdati$value)->subdati$value
    
      auto.arima(y=subdati$value,xreg = as.matrix(subdati[,c("banda","t2m","sp","pblmax","pblmin","wdir","wspeed","tp","ptp","pvalue","lockdown")]),
                 stepwise = TRUE,max.p=1,max.q=0)->ris
      print("###########################################\n")
      print(paste0("Codice stazione (station_eu_code):",cc))
      print("###########################################\n")  
      summary(ris)
      
    })


})
```

### Stazioni Rural

```{r,include=TRUE,echo=TRUE,message=FALSE,warning=FALSE}
purrr::walk(c("R"),.f=function(tipo){
  
    dati[dati$tipo_zona==tipo,]->dati2  
    
    #Altre info
    unique(dati2$station_eu_code)->CODICI
    
    purrr::walk(CODICI,.f=function(cc){
      dati2[dati2$station_eu_code==cc,]->subdati
      imputeTS::na_ma(subdati$value)->subdati$value
    
      auto.arima(y=subdati$value,xreg = as.matrix(subdati[,c("banda","t2m","sp","pblmax","pblmin","wdir","wspeed","tp","ptp","pvalue","lockdown")]),
                 stepwise = TRUE,max.p=1,max.q=0)->ris
      print("###########################################\n")
      print(paste0("Codice stazione (station_eu_code):",cc))
      print("###########################################\n")  
     summary(ris)
      
    })


})
```